// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/params"
	"math/big"
	"pkg.berachain.dev/polaris/eth/core/vm"
	"sync"
)

// Ensure, that BlackfuryStateDBMock does implement vm.BlackfuryStateDB.
// If this is not the case, regenerate this file with moq.
var _ vm.BlackfuryStateDB = &BlackfuryStateDBMock{}

// BlackfuryStateDBMock is a mock implementation of vm.BlackfuryStateDB.
//
//	func TestSomethingThatUsesBlackfuryStateDB(t *testing.T) {
//
//		// make and configure a mocked vm.BlackfuryStateDB
//		mockedBlackfuryStateDB := &BlackfuryStateDBMock{
//			AddAddressToAccessListFunc: func(addr common.Address)  {
//				panic("mock out the AddAddressToAccessList method")
//			},
//			AddBalanceFunc: func(address common.Address, intMoqParam *big.Int)  {
//				panic("mock out the AddBalance method")
//			},
//			AddLogFunc: func(log *types.Log)  {
//				panic("mock out the AddLog method")
//			},
//			AddPreimageFunc: func(hash common.Hash, bytes []byte)  {
//				panic("mock out the AddPreimage method")
//			},
//			AddRefundFunc: func(v uint64)  {
//				panic("mock out the AddRefund method")
//			},
//			AddSlotToAccessListFunc: func(addr common.Address, slot common.Hash)  {
//				panic("mock out the AddSlotToAccessList method")
//			},
//			AddressInAccessListFunc: func(addr common.Address) bool {
//				panic("mock out the AddressInAccessList method")
//			},
//			CommitFunc: func(deleteEmptyObjects bool) (common.Hash, error) {
//				panic("mock out the Commit method")
//			},
//			CopyFunc: func() state.StateDBI {
//				panic("mock out the Copy method")
//			},
//			CreateAccountFunc: func(address common.Address)  {
//				panic("mock out the CreateAccount method")
//			},
//			DatabaseFunc: func() state.Database {
//				panic("mock out the Database method")
//			},
//			DumpFunc: func(opts *state.DumpConfig) []byte {
//				panic("mock out the Dump method")
//			},
//			DumpToCollectorFunc: func(c state.DumpCollector, conf *state.DumpConfig) []byte {
//				panic("mock out the DumpToCollector method")
//			},
//			EmptyFunc: func(address common.Address) bool {
//				panic("mock out the Empty method")
//			},
//			ErrorFunc: func() error {
//				panic("mock out the Error method")
//			},
//			ExistFunc: func(address common.Address) bool {
//				panic("mock out the Exist method")
//			},
//			FinaliseFunc: func(deleteEmptyObjects bool)  {
//				panic("mock out the Finalise method")
//			},
//			ForEachStorageFunc: func(address common.Address, fn func(common.Hash, common.Hash) bool) error {
//				panic("mock out the ForEachStorage method")
//			},
//			GetBalanceFunc: func(address common.Address) *big.Int {
//				panic("mock out the GetBalance method")
//			},
//			GetCodeFunc: func(address common.Address) []byte {
//				panic("mock out the GetCode method")
//			},
//			GetCodeHashFunc: func(address common.Address) common.Hash {
//				panic("mock out the GetCodeHash method")
//			},
//			GetCodeSizeFunc: func(address common.Address) int {
//				panic("mock out the GetCodeSize method")
//			},
//			GetCommittedStateFunc: func(address common.Address, hash common.Hash) common.Hash {
//				panic("mock out the GetCommittedState method")
//			},
//			GetContextFunc: func() context.Context {
//				panic("mock out the GetContext method")
//			},
//			GetLogsFunc: func(hash common.Hash, blockNumber uint64, blockHash common.Hash) []*types.Log {
//				panic("mock out the GetLogs method")
//			},
//			GetNonceFunc: func(address common.Address) uint64 {
//				panic("mock out the GetNonce method")
//			},
//			GetOrNewStateObjectFunc: func(addr common.Address) *state.StateObject {
//				panic("mock out the GetOrNewStateObject method")
//			},
//			GetProofFunc: func(addr common.Address) ([][]byte, error) {
//				panic("mock out the GetProof method")
//			},
//			GetRefundFunc: func() uint64 {
//				panic("mock out the GetRefund method")
//			},
//			GetStateFunc: func(address common.Address, hash common.Hash) common.Hash {
//				panic("mock out the GetState method")
//			},
//			GetStorageProofFunc: func(a common.Address, key common.Hash) ([][]byte, error) {
//				panic("mock out the GetStorageProof method")
//			},
//			GetTransientStateFunc: func(addr common.Address, key common.Hash) common.Hash {
//				panic("mock out the GetTransientState method")
//			},
//			HasSuicidedFunc: func(address common.Address) bool {
//				panic("mock out the HasSuicided method")
//			},
//			IntermediateRootFunc: func(deleteEmptyObjects bool) common.Hash {
//				panic("mock out the IntermediateRoot method")
//			},
//			IteratorDumpFunc: func(opts *state.DumpConfig) state.IteratorDump {
//				panic("mock out the IteratorDump method")
//			},
//			LogsFunc: func() []*types.Log {
//				panic("mock out the Logs method")
//			},
//			PreimagesFunc: func() map[common.Hash][]byte {
//				panic("mock out the Preimages method")
//			},
//			PrepareFunc: func(rules params.Rules, sender common.Address, coinbase common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList)  {
//				panic("mock out the Prepare method")
//			},
//			RawDumpFunc: func(opts *state.DumpConfig) state.Dump {
//				panic("mock out the RawDump method")
//			},
//			RevertToSnapshotFunc: func(n int)  {
//				panic("mock out the RevertToSnapshot method")
//			},
//			SetBalanceFunc: func(addr common.Address, amount *big.Int)  {
//				panic("mock out the SetBalance method")
//			},
//			SetCodeFunc: func(address common.Address, bytes []byte)  {
//				panic("mock out the SetCode method")
//			},
//			SetNonceFunc: func(address common.Address, v uint64)  {
//				panic("mock out the SetNonce method")
//			},
//			SetStateFunc: func(address common.Address, hash1 common.Hash, hash2 common.Hash)  {
//				panic("mock out the SetState method")
//			},
//			SetStorageFunc: func(addr common.Address, storage map[common.Hash]common.Hash)  {
//				panic("mock out the SetStorage method")
//			},
//			SetTransientStateFunc: func(addr common.Address, key common.Hash, value common.Hash)  {
//				panic("mock out the SetTransientState method")
//			},
//			SetTxContextFunc: func(thash common.Hash, ti int)  {
//				panic("mock out the SetTxContext method")
//			},
//			SlotInAccessListFunc: func(addr common.Address, slot common.Hash) (bool, bool) {
//				panic("mock out the SlotInAccessList method")
//			},
//			SnapshotFunc: func() int {
//				panic("mock out the Snapshot method")
//			},
//			StartPrefetcherFunc: func(namespace string)  {
//				panic("mock out the StartPrefetcher method")
//			},
//			StopPrefetcherFunc: func()  {
//				panic("mock out the StopPrefetcher method")
//			},
//			StorageTrieFunc: func(addr common.Address) (state.Trie, error) {
//				panic("mock out the StorageTrie method")
//			},
//			SubBalanceFunc: func(address common.Address, intMoqParam *big.Int)  {
//				panic("mock out the SubBalance method")
//			},
//			SubRefundFunc: func(v uint64)  {
//				panic("mock out the SubRefund method")
//			},
//			SuicideFunc: func(address common.Address) bool {
//				panic("mock out the Suicide method")
//			},
//			TxIndexFunc: func() int {
//				panic("mock out the TxIndex method")
//			},
//		}
//
//		// use mockedBlackfuryStateDB in code that requires vm.BlackfuryStateDB
//		// and then make assertions.
//
//	}
type BlackfuryStateDBMock struct {
	// AddAddressToAccessListFunc mocks the AddAddressToAccessList method.
	AddAddressToAccessListFunc func(addr common.Address)

	// AddBalanceFunc mocks the AddBalance method.
	AddBalanceFunc func(address common.Address, intMoqParam *big.Int)

	// AddLogFunc mocks the AddLog method.
	AddLogFunc func(log *types.Log)

	// AddPreimageFunc mocks the AddPreimage method.
	AddPreimageFunc func(hash common.Hash, bytes []byte)

	// AddRefundFunc mocks the AddRefund method.
	AddRefundFunc func(v uint64)

	// AddSlotToAccessListFunc mocks the AddSlotToAccessList method.
	AddSlotToAccessListFunc func(addr common.Address, slot common.Hash)

	// AddressInAccessListFunc mocks the AddressInAccessList method.
	AddressInAccessListFunc func(addr common.Address) bool

	// CommitFunc mocks the Commit method.
	CommitFunc func(deleteEmptyObjects bool) (common.Hash, error)

	// CopyFunc mocks the Copy method.
	CopyFunc func() state.StateDBI

	// CreateAccountFunc mocks the CreateAccount method.
	CreateAccountFunc func(address common.Address)

	// DatabaseFunc mocks the Database method.
	DatabaseFunc func() state.Database

	// DumpFunc mocks the Dump method.
	DumpFunc func(opts *state.DumpConfig) []byte

	// DumpToCollectorFunc mocks the DumpToCollector method.
	DumpToCollectorFunc func(c state.DumpCollector, conf *state.DumpConfig) []byte

	// EmptyFunc mocks the Empty method.
	EmptyFunc func(address common.Address) bool

	// ErrorFunc mocks the Error method.
	ErrorFunc func() error

	// ExistFunc mocks the Exist method.
	ExistFunc func(address common.Address) bool

	// FinaliseFunc mocks the Finalise method.
	FinaliseFunc func(deleteEmptyObjects bool)

	// ForEachStorageFunc mocks the ForEachStorage method.
	ForEachStorageFunc func(address common.Address, fn func(common.Hash, common.Hash) bool) error

	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(address common.Address) *big.Int

	// GetCodeFunc mocks the GetCode method.
	GetCodeFunc func(address common.Address) []byte

	// GetCodeHashFunc mocks the GetCodeHash method.
	GetCodeHashFunc func(address common.Address) common.Hash

	// GetCodeSizeFunc mocks the GetCodeSize method.
	GetCodeSizeFunc func(address common.Address) int

	// GetCommittedStateFunc mocks the GetCommittedState method.
	GetCommittedStateFunc func(address common.Address, hash common.Hash) common.Hash

	// GetContextFunc mocks the GetContext method.
	GetContextFunc func() context.Context

	// GetLogsFunc mocks the GetLogs method.
	GetLogsFunc func(hash common.Hash, blockNumber uint64, blockHash common.Hash) []*types.Log

	// GetNonceFunc mocks the GetNonce method.
	GetNonceFunc func(address common.Address) uint64

	// GetOrNewStateObjectFunc mocks the GetOrNewStateObject method.
	GetOrNewStateObjectFunc func(addr common.Address) *state.StateObject

	// GetProofFunc mocks the GetProof method.
	GetProofFunc func(addr common.Address) ([][]byte, error)

	// GetRefundFunc mocks the GetRefund method.
	GetRefundFunc func() uint64

	// GetStateFunc mocks the GetState method.
	GetStateFunc func(address common.Address, hash common.Hash) common.Hash

	// GetStorageProofFunc mocks the GetStorageProof method.
	GetStorageProofFunc func(a common.Address, key common.Hash) ([][]byte, error)

	// GetTransientStateFunc mocks the GetTransientState method.
	GetTransientStateFunc func(addr common.Address, key common.Hash) common.Hash

	// HasSuicidedFunc mocks the HasSuicided method.
	HasSuicidedFunc func(address common.Address) bool

	// IntermediateRootFunc mocks the IntermediateRoot method.
	IntermediateRootFunc func(deleteEmptyObjects bool) common.Hash

	// IteratorDumpFunc mocks the IteratorDump method.
	IteratorDumpFunc func(opts *state.DumpConfig) state.IteratorDump

	// LogsFunc mocks the Logs method.
	LogsFunc func() []*types.Log

	// PreimagesFunc mocks the Preimages method.
	PreimagesFunc func() map[common.Hash][]byte

	// PrepareFunc mocks the Prepare method.
	PrepareFunc func(rules params.Rules, sender common.Address, coinbase common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList)

	// RawDumpFunc mocks the RawDump method.
	RawDumpFunc func(opts *state.DumpConfig) state.Dump

	// RevertToSnapshotFunc mocks the RevertToSnapshot method.
	RevertToSnapshotFunc func(n int)

	// SetBalanceFunc mocks the SetBalance method.
	SetBalanceFunc func(addr common.Address, amount *big.Int)

	// SetCodeFunc mocks the SetCode method.
	SetCodeFunc func(address common.Address, bytes []byte)

	// SetNonceFunc mocks the SetNonce method.
	SetNonceFunc func(address common.Address, v uint64)

	// SetStateFunc mocks the SetState method.
	SetStateFunc func(address common.Address, hash1 common.Hash, hash2 common.Hash)

	// SetStorageFunc mocks the SetStorage method.
	SetStorageFunc func(addr common.Address, storage map[common.Hash]common.Hash)

	// SetTransientStateFunc mocks the SetTransientState method.
	SetTransientStateFunc func(addr common.Address, key common.Hash, value common.Hash)

	// SetTxContextFunc mocks the SetTxContext method.
	SetTxContextFunc func(thash common.Hash, ti int)

	// SlotInAccessListFunc mocks the SlotInAccessList method.
	SlotInAccessListFunc func(addr common.Address, slot common.Hash) (bool, bool)

	// SnapshotFunc mocks the Snapshot method.
	SnapshotFunc func() int

	// StartPrefetcherFunc mocks the StartPrefetcher method.
	StartPrefetcherFunc func(namespace string)

	// StopPrefetcherFunc mocks the StopPrefetcher method.
	StopPrefetcherFunc func()

	// StorageTrieFunc mocks the StorageTrie method.
	StorageTrieFunc func(addr common.Address) (state.Trie, error)

	// SubBalanceFunc mocks the SubBalance method.
	SubBalanceFunc func(address common.Address, intMoqParam *big.Int)

	// SubRefundFunc mocks the SubRefund method.
	SubRefundFunc func(v uint64)

	// SuicideFunc mocks the Suicide method.
	SuicideFunc func(address common.Address) bool

	// TxIndexFunc mocks the TxIndex method.
	TxIndexFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// AddAddressToAccessList holds details about calls to the AddAddressToAccessList method.
		AddAddressToAccessList []struct {
			// Addr is the addr argument value.
			Addr common.Address
		}
		// AddBalance holds details about calls to the AddBalance method.
		AddBalance []struct {
			// Address is the address argument value.
			Address common.Address
			// IntMoqParam is the intMoqParam argument value.
			IntMoqParam *big.Int
		}
		// AddLog holds details about calls to the AddLog method.
		AddLog []struct {
			// Log is the log argument value.
			Log *types.Log
		}
		// AddPreimage holds details about calls to the AddPreimage method.
		AddPreimage []struct {
			// Hash is the hash argument value.
			Hash common.Hash
			// Bytes is the bytes argument value.
			Bytes []byte
		}
		// AddRefund holds details about calls to the AddRefund method.
		AddRefund []struct {
			// V is the v argument value.
			V uint64
		}
		// AddSlotToAccessList holds details about calls to the AddSlotToAccessList method.
		AddSlotToAccessList []struct {
			// Addr is the addr argument value.
			Addr common.Address
			// Slot is the slot argument value.
			Slot common.Hash
		}
		// AddressInAccessList holds details about calls to the AddressInAccessList method.
		AddressInAccessList []struct {
			// Addr is the addr argument value.
			Addr common.Address
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
			// DeleteEmptyObjects is the deleteEmptyObjects argument value.
			DeleteEmptyObjects bool
		}
		// Copy holds details about calls to the Copy method.
		Copy []struct {
		}
		// CreateAccount holds details about calls to the CreateAccount method.
		CreateAccount []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// Database holds details about calls to the Database method.
		Database []struct {
		}
		// Dump holds details about calls to the Dump method.
		Dump []struct {
			// Opts is the opts argument value.
			Opts *state.DumpConfig
		}
		// DumpToCollector holds details about calls to the DumpToCollector method.
		DumpToCollector []struct {
			// C is the c argument value.
			C state.DumpCollector
			// Conf is the conf argument value.
			Conf *state.DumpConfig
		}
		// Empty holds details about calls to the Empty method.
		Empty []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// Error holds details about calls to the Error method.
		Error []struct {
		}
		// Exist holds details about calls to the Exist method.
		Exist []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// Finalise holds details about calls to the Finalise method.
		Finalise []struct {
			// DeleteEmptyObjects is the deleteEmptyObjects argument value.
			DeleteEmptyObjects bool
		}
		// ForEachStorage holds details about calls to the ForEachStorage method.
		ForEachStorage []struct {
			// Address is the address argument value.
			Address common.Address
			// Fn is the fn argument value.
			Fn func(common.Hash, common.Hash) bool
		}
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// GetCode holds details about calls to the GetCode method.
		GetCode []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// GetCodeHash holds details about calls to the GetCodeHash method.
		GetCodeHash []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// GetCodeSize holds details about calls to the GetCodeSize method.
		GetCodeSize []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// GetCommittedState holds details about calls to the GetCommittedState method.
		GetCommittedState []struct {
			// Address is the address argument value.
			Address common.Address
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// GetContext holds details about calls to the GetContext method.
		GetContext []struct {
		}
		// GetLogs holds details about calls to the GetLogs method.
		GetLogs []struct {
			// Hash is the hash argument value.
			Hash common.Hash
			// BlockNumber is the blockNumber argument value.
			BlockNumber uint64
			// BlockHash is the blockHash argument value.
			BlockHash common.Hash
		}
		// GetNonce holds details about calls to the GetNonce method.
		GetNonce []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// GetOrNewStateObject holds details about calls to the GetOrNewStateObject method.
		GetOrNewStateObject []struct {
			// Addr is the addr argument value.
			Addr common.Address
		}
		// GetProof holds details about calls to the GetProof method.
		GetProof []struct {
			// Addr is the addr argument value.
			Addr common.Address
		}
		// GetRefund holds details about calls to the GetRefund method.
		GetRefund []struct {
		}
		// GetState holds details about calls to the GetState method.
		GetState []struct {
			// Address is the address argument value.
			Address common.Address
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// GetStorageProof holds details about calls to the GetStorageProof method.
		GetStorageProof []struct {
			// A is the a argument value.
			A common.Address
			// Key is the key argument value.
			Key common.Hash
		}
		// GetTransientState holds details about calls to the GetTransientState method.
		GetTransientState []struct {
			// Addr is the addr argument value.
			Addr common.Address
			// Key is the key argument value.
			Key common.Hash
		}
		// HasSuicided holds details about calls to the HasSuicided method.
		HasSuicided []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// IntermediateRoot holds details about calls to the IntermediateRoot method.
		IntermediateRoot []struct {
			// DeleteEmptyObjects is the deleteEmptyObjects argument value.
			DeleteEmptyObjects bool
		}
		// IteratorDump holds details about calls to the IteratorDump method.
		IteratorDump []struct {
			// Opts is the opts argument value.
			Opts *state.DumpConfig
		}
		// Logs holds details about calls to the Logs method.
		Logs []struct {
		}
		// Preimages holds details about calls to the Preimages method.
		Preimages []struct {
		}
		// Prepare holds details about calls to the Prepare method.
		Prepare []struct {
			// Rules is the rules argument value.
			Rules params.Rules
			// Sender is the sender argument value.
			Sender common.Address
			// Coinbase is the coinbase argument value.
			Coinbase common.Address
			// Dest is the dest argument value.
			Dest *common.Address
			// Precompiles is the precompiles argument value.
			Precompiles []common.Address
			// TxAccesses is the txAccesses argument value.
			TxAccesses types.AccessList
		}
		// RawDump holds details about calls to the RawDump method.
		RawDump []struct {
			// Opts is the opts argument value.
			Opts *state.DumpConfig
		}
		// RevertToSnapshot holds details about calls to the RevertToSnapshot method.
		RevertToSnapshot []struct {
			// N is the n argument value.
			N int
		}
		// SetBalance holds details about calls to the SetBalance method.
		SetBalance []struct {
			// Addr is the addr argument value.
			Addr common.Address
			// Amount is the amount argument value.
			Amount *big.Int
		}
		// SetCode holds details about calls to the SetCode method.
		SetCode []struct {
			// Address is the address argument value.
			Address common.Address
			// Bytes is the bytes argument value.
			Bytes []byte
		}
		// SetNonce holds details about calls to the SetNonce method.
		SetNonce []struct {
			// Address is the address argument value.
			Address common.Address
			// V is the v argument value.
			V uint64
		}
		// SetState holds details about calls to the SetState method.
		SetState []struct {
			// Address is the address argument value.
			Address common.Address
			// Hash1 is the hash1 argument value.
			Hash1 common.Hash
			// Hash2 is the hash2 argument value.
			Hash2 common.Hash
		}
		// SetStorage holds details about calls to the SetStorage method.
		SetStorage []struct {
			// Addr is the addr argument value.
			Addr common.Address
			// Storage is the storage argument value.
			Storage map[common.Hash]common.Hash
		}
		// SetTransientState holds details about calls to the SetTransientState method.
		SetTransientState []struct {
			// Addr is the addr argument value.
			Addr common.Address
			// Key is the key argument value.
			Key common.Hash
			// Value is the value argument value.
			Value common.Hash
		}
		// SetTxContext holds details about calls to the SetTxContext method.
		SetTxContext []struct {
			// Thash is the thash argument value.
			Thash common.Hash
			// Ti is the ti argument value.
			Ti int
		}
		// SlotInAccessList holds details about calls to the SlotInAccessList method.
		SlotInAccessList []struct {
			// Addr is the addr argument value.
			Addr common.Address
			// Slot is the slot argument value.
			Slot common.Hash
		}
		// Snapshot holds details about calls to the Snapshot method.
		Snapshot []struct {
		}
		// StartPrefetcher holds details about calls to the StartPrefetcher method.
		StartPrefetcher []struct {
			// Namespace is the namespace argument value.
			Namespace string
		}
		// StopPrefetcher holds details about calls to the StopPrefetcher method.
		StopPrefetcher []struct {
		}
		// StorageTrie holds details about calls to the StorageTrie method.
		StorageTrie []struct {
			// Addr is the addr argument value.
			Addr common.Address
		}
		// SubBalance holds details about calls to the SubBalance method.
		SubBalance []struct {
			// Address is the address argument value.
			Address common.Address
			// IntMoqParam is the intMoqParam argument value.
			IntMoqParam *big.Int
		}
		// SubRefund holds details about calls to the SubRefund method.
		SubRefund []struct {
			// V is the v argument value.
			V uint64
		}
		// Suicide holds details about calls to the Suicide method.
		Suicide []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// TxIndex holds details about calls to the TxIndex method.
		TxIndex []struct {
		}
	}
	lockAddAddressToAccessList sync.RWMutex
	lockAddBalance             sync.RWMutex
	lockAddLog                 sync.RWMutex
	lockAddPreimage            sync.RWMutex
	lockAddRefund              sync.RWMutex
	lockAddSlotToAccessList    sync.RWMutex
	lockAddressInAccessList    sync.RWMutex
	lockCommit                 sync.RWMutex
	lockCopy                   sync.RWMutex
	lockCreateAccount          sync.RWMutex
	lockDatabase               sync.RWMutex
	lockDump                   sync.RWMutex
	lockDumpToCollector        sync.RWMutex
	lockEmpty                  sync.RWMutex
	lockError                  sync.RWMutex
	lockExist                  sync.RWMutex
	lockFinalise               sync.RWMutex
	lockForEachStorage         sync.RWMutex
	lockGetBalance             sync.RWMutex
	lockGetCode                sync.RWMutex
	lockGetCodeHash            sync.RWMutex
	lockGetCodeSize            sync.RWMutex
	lockGetCommittedState      sync.RWMutex
	lockGetContext             sync.RWMutex
	lockGetLogs                sync.RWMutex
	lockGetNonce               sync.RWMutex
	lockGetOrNewStateObject    sync.RWMutex
	lockGetProof               sync.RWMutex
	lockGetRefund              sync.RWMutex
	lockGetState               sync.RWMutex
	lockGetStorageProof        sync.RWMutex
	lockGetTransientState      sync.RWMutex
	lockHasSuicided            sync.RWMutex
	lockIntermediateRoot       sync.RWMutex
	lockIteratorDump           sync.RWMutex
	lockLogs                   sync.RWMutex
	lockPreimages              sync.RWMutex
	lockPrepare                sync.RWMutex
	lockRawDump                sync.RWMutex
	lockRevertToSnapshot       sync.RWMutex
	lockSetBalance             sync.RWMutex
	lockSetCode                sync.RWMutex
	lockSetNonce               sync.RWMutex
	lockSetState               sync.RWMutex
	lockSetStorage             sync.RWMutex
	lockSetTransientState      sync.RWMutex
	lockSetTxContext           sync.RWMutex
	lockSlotInAccessList       sync.RWMutex
	lockSnapshot               sync.RWMutex
	lockStartPrefetcher        sync.RWMutex
	lockStopPrefetcher         sync.RWMutex
	lockStorageTrie            sync.RWMutex
	lockSubBalance             sync.RWMutex
	lockSubRefund              sync.RWMutex
	lockSuicide                sync.RWMutex
	lockTxIndex                sync.RWMutex
}

// AddAddressToAccessList calls AddAddressToAccessListFunc.
func (mock *BlackfuryStateDBMock) AddAddressToAccessList(addr common.Address) {
	if mock.AddAddressToAccessListFunc == nil {
		panic("BlackfuryStateDBMock.AddAddressToAccessListFunc: method is nil but BlackfuryStateDB.AddAddressToAccessList was just called")
	}
	callInfo := struct {
		Addr common.Address
	}{
		Addr: addr,
	}
	mock.lockAddAddressToAccessList.Lock()
	mock.calls.AddAddressToAccessList = append(mock.calls.AddAddressToAccessList, callInfo)
	mock.lockAddAddressToAccessList.Unlock()
	mock.AddAddressToAccessListFunc(addr)
}

// AddAddressToAccessListCalls gets all the calls that were made to AddAddressToAccessList.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddAddressToAccessListCalls())
func (mock *BlackfuryStateDBMock) AddAddressToAccessListCalls() []struct {
	Addr common.Address
} {
	var calls []struct {
		Addr common.Address
	}
	mock.lockAddAddressToAccessList.RLock()
	calls = mock.calls.AddAddressToAccessList
	mock.lockAddAddressToAccessList.RUnlock()
	return calls
}

// AddBalance calls AddBalanceFunc.
func (mock *BlackfuryStateDBMock) AddBalance(address common.Address, intMoqParam *big.Int) {
	if mock.AddBalanceFunc == nil {
		panic("BlackfuryStateDBMock.AddBalanceFunc: method is nil but BlackfuryStateDB.AddBalance was just called")
	}
	callInfo := struct {
		Address     common.Address
		IntMoqParam *big.Int
	}{
		Address:     address,
		IntMoqParam: intMoqParam,
	}
	mock.lockAddBalance.Lock()
	mock.calls.AddBalance = append(mock.calls.AddBalance, callInfo)
	mock.lockAddBalance.Unlock()
	mock.AddBalanceFunc(address, intMoqParam)
}

// AddBalanceCalls gets all the calls that were made to AddBalance.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddBalanceCalls())
func (mock *BlackfuryStateDBMock) AddBalanceCalls() []struct {
	Address     common.Address
	IntMoqParam *big.Int
} {
	var calls []struct {
		Address     common.Address
		IntMoqParam *big.Int
	}
	mock.lockAddBalance.RLock()
	calls = mock.calls.AddBalance
	mock.lockAddBalance.RUnlock()
	return calls
}

// AddLog calls AddLogFunc.
func (mock *BlackfuryStateDBMock) AddLog(log *types.Log) {
	if mock.AddLogFunc == nil {
		panic("BlackfuryStateDBMock.AddLogFunc: method is nil but BlackfuryStateDB.AddLog was just called")
	}
	callInfo := struct {
		Log *types.Log
	}{
		Log: log,
	}
	mock.lockAddLog.Lock()
	mock.calls.AddLog = append(mock.calls.AddLog, callInfo)
	mock.lockAddLog.Unlock()
	mock.AddLogFunc(log)
}

// AddLogCalls gets all the calls that were made to AddLog.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddLogCalls())
func (mock *BlackfuryStateDBMock) AddLogCalls() []struct {
	Log *types.Log
} {
	var calls []struct {
		Log *types.Log
	}
	mock.lockAddLog.RLock()
	calls = mock.calls.AddLog
	mock.lockAddLog.RUnlock()
	return calls
}

// AddPreimage calls AddPreimageFunc.
func (mock *BlackfuryStateDBMock) AddPreimage(hash common.Hash, bytes []byte) {
	if mock.AddPreimageFunc == nil {
		panic("BlackfuryStateDBMock.AddPreimageFunc: method is nil but BlackfuryStateDB.AddPreimage was just called")
	}
	callInfo := struct {
		Hash  common.Hash
		Bytes []byte
	}{
		Hash:  hash,
		Bytes: bytes,
	}
	mock.lockAddPreimage.Lock()
	mock.calls.AddPreimage = append(mock.calls.AddPreimage, callInfo)
	mock.lockAddPreimage.Unlock()
	mock.AddPreimageFunc(hash, bytes)
}

// AddPreimageCalls gets all the calls that were made to AddPreimage.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddPreimageCalls())
func (mock *BlackfuryStateDBMock) AddPreimageCalls() []struct {
	Hash  common.Hash
	Bytes []byte
} {
	var calls []struct {
		Hash  common.Hash
		Bytes []byte
	}
	mock.lockAddPreimage.RLock()
	calls = mock.calls.AddPreimage
	mock.lockAddPreimage.RUnlock()
	return calls
}

// AddRefund calls AddRefundFunc.
func (mock *BlackfuryStateDBMock) AddRefund(v uint64) {
	if mock.AddRefundFunc == nil {
		panic("BlackfuryStateDBMock.AddRefundFunc: method is nil but BlackfuryStateDB.AddRefund was just called")
	}
	callInfo := struct {
		V uint64
	}{
		V: v,
	}
	mock.lockAddRefund.Lock()
	mock.calls.AddRefund = append(mock.calls.AddRefund, callInfo)
	mock.lockAddRefund.Unlock()
	mock.AddRefundFunc(v)
}

// AddRefundCalls gets all the calls that were made to AddRefund.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddRefundCalls())
func (mock *BlackfuryStateDBMock) AddRefundCalls() []struct {
	V uint64
} {
	var calls []struct {
		V uint64
	}
	mock.lockAddRefund.RLock()
	calls = mock.calls.AddRefund
	mock.lockAddRefund.RUnlock()
	return calls
}

// AddSlotToAccessList calls AddSlotToAccessListFunc.
func (mock *BlackfuryStateDBMock) AddSlotToAccessList(addr common.Address, slot common.Hash) {
	if mock.AddSlotToAccessListFunc == nil {
		panic("BlackfuryStateDBMock.AddSlotToAccessListFunc: method is nil but BlackfuryStateDB.AddSlotToAccessList was just called")
	}
	callInfo := struct {
		Addr common.Address
		Slot common.Hash
	}{
		Addr: addr,
		Slot: slot,
	}
	mock.lockAddSlotToAccessList.Lock()
	mock.calls.AddSlotToAccessList = append(mock.calls.AddSlotToAccessList, callInfo)
	mock.lockAddSlotToAccessList.Unlock()
	mock.AddSlotToAccessListFunc(addr, slot)
}

// AddSlotToAccessListCalls gets all the calls that were made to AddSlotToAccessList.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddSlotToAccessListCalls())
func (mock *BlackfuryStateDBMock) AddSlotToAccessListCalls() []struct {
	Addr common.Address
	Slot common.Hash
} {
	var calls []struct {
		Addr common.Address
		Slot common.Hash
	}
	mock.lockAddSlotToAccessList.RLock()
	calls = mock.calls.AddSlotToAccessList
	mock.lockAddSlotToAccessList.RUnlock()
	return calls
}

// AddressInAccessList calls AddressInAccessListFunc.
func (mock *BlackfuryStateDBMock) AddressInAccessList(addr common.Address) bool {
	if mock.AddressInAccessListFunc == nil {
		panic("BlackfuryStateDBMock.AddressInAccessListFunc: method is nil but BlackfuryStateDB.AddressInAccessList was just called")
	}
	callInfo := struct {
		Addr common.Address
	}{
		Addr: addr,
	}
	mock.lockAddressInAccessList.Lock()
	mock.calls.AddressInAccessList = append(mock.calls.AddressInAccessList, callInfo)
	mock.lockAddressInAccessList.Unlock()
	return mock.AddressInAccessListFunc(addr)
}

// AddressInAccessListCalls gets all the calls that were made to AddressInAccessList.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.AddressInAccessListCalls())
func (mock *BlackfuryStateDBMock) AddressInAccessListCalls() []struct {
	Addr common.Address
} {
	var calls []struct {
		Addr common.Address
	}
	mock.lockAddressInAccessList.RLock()
	calls = mock.calls.AddressInAccessList
	mock.lockAddressInAccessList.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *BlackfuryStateDBMock) Commit(deleteEmptyObjects bool) (common.Hash, error) {
	if mock.CommitFunc == nil {
		panic("BlackfuryStateDBMock.CommitFunc: method is nil but BlackfuryStateDB.Commit was just called")
	}
	callInfo := struct {
		DeleteEmptyObjects bool
	}{
		DeleteEmptyObjects: deleteEmptyObjects,
	}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc(deleteEmptyObjects)
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.CommitCalls())
func (mock *BlackfuryStateDBMock) CommitCalls() []struct {
	DeleteEmptyObjects bool
} {
	var calls []struct {
		DeleteEmptyObjects bool
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// Copy calls CopyFunc.
func (mock *BlackfuryStateDBMock) Copy() state.StateDBI {
	if mock.CopyFunc == nil {
		panic("BlackfuryStateDBMock.CopyFunc: method is nil but BlackfuryStateDB.Copy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCopy.Lock()
	mock.calls.Copy = append(mock.calls.Copy, callInfo)
	mock.lockCopy.Unlock()
	return mock.CopyFunc()
}

// CopyCalls gets all the calls that were made to Copy.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.CopyCalls())
func (mock *BlackfuryStateDBMock) CopyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCopy.RLock()
	calls = mock.calls.Copy
	mock.lockCopy.RUnlock()
	return calls
}

// CreateAccount calls CreateAccountFunc.
func (mock *BlackfuryStateDBMock) CreateAccount(address common.Address) {
	if mock.CreateAccountFunc == nil {
		panic("BlackfuryStateDBMock.CreateAccountFunc: method is nil but BlackfuryStateDB.CreateAccount was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockCreateAccount.Lock()
	mock.calls.CreateAccount = append(mock.calls.CreateAccount, callInfo)
	mock.lockCreateAccount.Unlock()
	mock.CreateAccountFunc(address)
}

// CreateAccountCalls gets all the calls that were made to CreateAccount.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.CreateAccountCalls())
func (mock *BlackfuryStateDBMock) CreateAccountCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockCreateAccount.RLock()
	calls = mock.calls.CreateAccount
	mock.lockCreateAccount.RUnlock()
	return calls
}

// Database calls DatabaseFunc.
func (mock *BlackfuryStateDBMock) Database() state.Database {
	if mock.DatabaseFunc == nil {
		panic("BlackfuryStateDBMock.DatabaseFunc: method is nil but BlackfuryStateDB.Database was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDatabase.Lock()
	mock.calls.Database = append(mock.calls.Database, callInfo)
	mock.lockDatabase.Unlock()
	return mock.DatabaseFunc()
}

// DatabaseCalls gets all the calls that were made to Database.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.DatabaseCalls())
func (mock *BlackfuryStateDBMock) DatabaseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDatabase.RLock()
	calls = mock.calls.Database
	mock.lockDatabase.RUnlock()
	return calls
}

// Dump calls DumpFunc.
func (mock *BlackfuryStateDBMock) Dump(opts *state.DumpConfig) []byte {
	if mock.DumpFunc == nil {
		panic("BlackfuryStateDBMock.DumpFunc: method is nil but BlackfuryStateDB.Dump was just called")
	}
	callInfo := struct {
		Opts *state.DumpConfig
	}{
		Opts: opts,
	}
	mock.lockDump.Lock()
	mock.calls.Dump = append(mock.calls.Dump, callInfo)
	mock.lockDump.Unlock()
	return mock.DumpFunc(opts)
}

// DumpCalls gets all the calls that were made to Dump.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.DumpCalls())
func (mock *BlackfuryStateDBMock) DumpCalls() []struct {
	Opts *state.DumpConfig
} {
	var calls []struct {
		Opts *state.DumpConfig
	}
	mock.lockDump.RLock()
	calls = mock.calls.Dump
	mock.lockDump.RUnlock()
	return calls
}

// DumpToCollector calls DumpToCollectorFunc.
func (mock *BlackfuryStateDBMock) DumpToCollector(c state.DumpCollector, conf *state.DumpConfig) []byte {
	if mock.DumpToCollectorFunc == nil {
		panic("BlackfuryStateDBMock.DumpToCollectorFunc: method is nil but BlackfuryStateDB.DumpToCollector was just called")
	}
	callInfo := struct {
		C    state.DumpCollector
		Conf *state.DumpConfig
	}{
		C:    c,
		Conf: conf,
	}
	mock.lockDumpToCollector.Lock()
	mock.calls.DumpToCollector = append(mock.calls.DumpToCollector, callInfo)
	mock.lockDumpToCollector.Unlock()
	return mock.DumpToCollectorFunc(c, conf)
}

// DumpToCollectorCalls gets all the calls that were made to DumpToCollector.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.DumpToCollectorCalls())
func (mock *BlackfuryStateDBMock) DumpToCollectorCalls() []struct {
	C    state.DumpCollector
	Conf *state.DumpConfig
} {
	var calls []struct {
		C    state.DumpCollector
		Conf *state.DumpConfig
	}
	mock.lockDumpToCollector.RLock()
	calls = mock.calls.DumpToCollector
	mock.lockDumpToCollector.RUnlock()
	return calls
}

// Empty calls EmptyFunc.
func (mock *BlackfuryStateDBMock) Empty(address common.Address) bool {
	if mock.EmptyFunc == nil {
		panic("BlackfuryStateDBMock.EmptyFunc: method is nil but BlackfuryStateDB.Empty was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockEmpty.Lock()
	mock.calls.Empty = append(mock.calls.Empty, callInfo)
	mock.lockEmpty.Unlock()
	return mock.EmptyFunc(address)
}

// EmptyCalls gets all the calls that were made to Empty.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.EmptyCalls())
func (mock *BlackfuryStateDBMock) EmptyCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockEmpty.RLock()
	calls = mock.calls.Empty
	mock.lockEmpty.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *BlackfuryStateDBMock) Error() error {
	if mock.ErrorFunc == nil {
		panic("BlackfuryStateDBMock.ErrorFunc: method is nil but BlackfuryStateDB.Error was just called")
	}
	callInfo := struct {
	}{}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	return mock.ErrorFunc()
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.ErrorCalls())
func (mock *BlackfuryStateDBMock) ErrorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Exist calls ExistFunc.
func (mock *BlackfuryStateDBMock) Exist(address common.Address) bool {
	if mock.ExistFunc == nil {
		panic("BlackfuryStateDBMock.ExistFunc: method is nil but BlackfuryStateDB.Exist was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockExist.Lock()
	mock.calls.Exist = append(mock.calls.Exist, callInfo)
	mock.lockExist.Unlock()
	return mock.ExistFunc(address)
}

// ExistCalls gets all the calls that were made to Exist.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.ExistCalls())
func (mock *BlackfuryStateDBMock) ExistCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockExist.RLock()
	calls = mock.calls.Exist
	mock.lockExist.RUnlock()
	return calls
}

// Finalise calls FinaliseFunc.
func (mock *BlackfuryStateDBMock) Finalise(deleteEmptyObjects bool) {
	if mock.FinaliseFunc == nil {
		panic("BlackfuryStateDBMock.FinaliseFunc: method is nil but BlackfuryStateDB.Finalise was just called")
	}
	callInfo := struct {
		DeleteEmptyObjects bool
	}{
		DeleteEmptyObjects: deleteEmptyObjects,
	}
	mock.lockFinalise.Lock()
	mock.calls.Finalise = append(mock.calls.Finalise, callInfo)
	mock.lockFinalise.Unlock()
	mock.FinaliseFunc(deleteEmptyObjects)
}

// FinaliseCalls gets all the calls that were made to Finalise.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.FinaliseCalls())
func (mock *BlackfuryStateDBMock) FinaliseCalls() []struct {
	DeleteEmptyObjects bool
} {
	var calls []struct {
		DeleteEmptyObjects bool
	}
	mock.lockFinalise.RLock()
	calls = mock.calls.Finalise
	mock.lockFinalise.RUnlock()
	return calls
}

// ForEachStorage calls ForEachStorageFunc.
func (mock *BlackfuryStateDBMock) ForEachStorage(address common.Address, fn func(common.Hash, common.Hash) bool) error {
	if mock.ForEachStorageFunc == nil {
		panic("BlackfuryStateDBMock.ForEachStorageFunc: method is nil but BlackfuryStateDB.ForEachStorage was just called")
	}
	callInfo := struct {
		Address common.Address
		Fn      func(common.Hash, common.Hash) bool
	}{
		Address: address,
		Fn:      fn,
	}
	mock.lockForEachStorage.Lock()
	mock.calls.ForEachStorage = append(mock.calls.ForEachStorage, callInfo)
	mock.lockForEachStorage.Unlock()
	return mock.ForEachStorageFunc(address, fn)
}

// ForEachStorageCalls gets all the calls that were made to ForEachStorage.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.ForEachStorageCalls())
func (mock *BlackfuryStateDBMock) ForEachStorageCalls() []struct {
	Address common.Address
	Fn      func(common.Hash, common.Hash) bool
} {
	var calls []struct {
		Address common.Address
		Fn      func(common.Hash, common.Hash) bool
	}
	mock.lockForEachStorage.RLock()
	calls = mock.calls.ForEachStorage
	mock.lockForEachStorage.RUnlock()
	return calls
}

// GetBalance calls GetBalanceFunc.
func (mock *BlackfuryStateDBMock) GetBalance(address common.Address) *big.Int {
	if mock.GetBalanceFunc == nil {
		panic("BlackfuryStateDBMock.GetBalanceFunc: method is nil but BlackfuryStateDB.GetBalance was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	return mock.GetBalanceFunc(address)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetBalanceCalls())
func (mock *BlackfuryStateDBMock) GetBalanceCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// GetCode calls GetCodeFunc.
func (mock *BlackfuryStateDBMock) GetCode(address common.Address) []byte {
	if mock.GetCodeFunc == nil {
		panic("BlackfuryStateDBMock.GetCodeFunc: method is nil but BlackfuryStateDB.GetCode was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockGetCode.Lock()
	mock.calls.GetCode = append(mock.calls.GetCode, callInfo)
	mock.lockGetCode.Unlock()
	return mock.GetCodeFunc(address)
}

// GetCodeCalls gets all the calls that were made to GetCode.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetCodeCalls())
func (mock *BlackfuryStateDBMock) GetCodeCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockGetCode.RLock()
	calls = mock.calls.GetCode
	mock.lockGetCode.RUnlock()
	return calls
}

// GetCodeHash calls GetCodeHashFunc.
func (mock *BlackfuryStateDBMock) GetCodeHash(address common.Address) common.Hash {
	if mock.GetCodeHashFunc == nil {
		panic("BlackfuryStateDBMock.GetCodeHashFunc: method is nil but BlackfuryStateDB.GetCodeHash was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockGetCodeHash.Lock()
	mock.calls.GetCodeHash = append(mock.calls.GetCodeHash, callInfo)
	mock.lockGetCodeHash.Unlock()
	return mock.GetCodeHashFunc(address)
}

// GetCodeHashCalls gets all the calls that were made to GetCodeHash.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetCodeHashCalls())
func (mock *BlackfuryStateDBMock) GetCodeHashCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockGetCodeHash.RLock()
	calls = mock.calls.GetCodeHash
	mock.lockGetCodeHash.RUnlock()
	return calls
}

// GetCodeSize calls GetCodeSizeFunc.
func (mock *BlackfuryStateDBMock) GetCodeSize(address common.Address) int {
	if mock.GetCodeSizeFunc == nil {
		panic("BlackfuryStateDBMock.GetCodeSizeFunc: method is nil but BlackfuryStateDB.GetCodeSize was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockGetCodeSize.Lock()
	mock.calls.GetCodeSize = append(mock.calls.GetCodeSize, callInfo)
	mock.lockGetCodeSize.Unlock()
	return mock.GetCodeSizeFunc(address)
}

// GetCodeSizeCalls gets all the calls that were made to GetCodeSize.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetCodeSizeCalls())
func (mock *BlackfuryStateDBMock) GetCodeSizeCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockGetCodeSize.RLock()
	calls = mock.calls.GetCodeSize
	mock.lockGetCodeSize.RUnlock()
	return calls
}

// GetCommittedState calls GetCommittedStateFunc.
func (mock *BlackfuryStateDBMock) GetCommittedState(address common.Address, hash common.Hash) common.Hash {
	if mock.GetCommittedStateFunc == nil {
		panic("BlackfuryStateDBMock.GetCommittedStateFunc: method is nil but BlackfuryStateDB.GetCommittedState was just called")
	}
	callInfo := struct {
		Address common.Address
		Hash    common.Hash
	}{
		Address: address,
		Hash:    hash,
	}
	mock.lockGetCommittedState.Lock()
	mock.calls.GetCommittedState = append(mock.calls.GetCommittedState, callInfo)
	mock.lockGetCommittedState.Unlock()
	return mock.GetCommittedStateFunc(address, hash)
}

// GetCommittedStateCalls gets all the calls that were made to GetCommittedState.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetCommittedStateCalls())
func (mock *BlackfuryStateDBMock) GetCommittedStateCalls() []struct {
	Address common.Address
	Hash    common.Hash
} {
	var calls []struct {
		Address common.Address
		Hash    common.Hash
	}
	mock.lockGetCommittedState.RLock()
	calls = mock.calls.GetCommittedState
	mock.lockGetCommittedState.RUnlock()
	return calls
}

// GetContext calls GetContextFunc.
func (mock *BlackfuryStateDBMock) GetContext() context.Context {
	if mock.GetContextFunc == nil {
		panic("BlackfuryStateDBMock.GetContextFunc: method is nil but BlackfuryStateDB.GetContext was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetContext.Lock()
	mock.calls.GetContext = append(mock.calls.GetContext, callInfo)
	mock.lockGetContext.Unlock()
	return mock.GetContextFunc()
}

// GetContextCalls gets all the calls that were made to GetContext.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetContextCalls())
func (mock *BlackfuryStateDBMock) GetContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetContext.RLock()
	calls = mock.calls.GetContext
	mock.lockGetContext.RUnlock()
	return calls
}

// GetLogs calls GetLogsFunc.
func (mock *BlackfuryStateDBMock) GetLogs(hash common.Hash, blockNumber uint64, blockHash common.Hash) []*types.Log {
	if mock.GetLogsFunc == nil {
		panic("BlackfuryStateDBMock.GetLogsFunc: method is nil but BlackfuryStateDB.GetLogs was just called")
	}
	callInfo := struct {
		Hash        common.Hash
		BlockNumber uint64
		BlockHash   common.Hash
	}{
		Hash:        hash,
		BlockNumber: blockNumber,
		BlockHash:   blockHash,
	}
	mock.lockGetLogs.Lock()
	mock.calls.GetLogs = append(mock.calls.GetLogs, callInfo)
	mock.lockGetLogs.Unlock()
	return mock.GetLogsFunc(hash, blockNumber, blockHash)
}

// GetLogsCalls gets all the calls that were made to GetLogs.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetLogsCalls())
func (mock *BlackfuryStateDBMock) GetLogsCalls() []struct {
	Hash        common.Hash
	BlockNumber uint64
	BlockHash   common.Hash
} {
	var calls []struct {
		Hash        common.Hash
		BlockNumber uint64
		BlockHash   common.Hash
	}
	mock.lockGetLogs.RLock()
	calls = mock.calls.GetLogs
	mock.lockGetLogs.RUnlock()
	return calls
}

// GetNonce calls GetNonceFunc.
func (mock *BlackfuryStateDBMock) GetNonce(address common.Address) uint64 {
	if mock.GetNonceFunc == nil {
		panic("BlackfuryStateDBMock.GetNonceFunc: method is nil but BlackfuryStateDB.GetNonce was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockGetNonce.Lock()
	mock.calls.GetNonce = append(mock.calls.GetNonce, callInfo)
	mock.lockGetNonce.Unlock()
	return mock.GetNonceFunc(address)
}

// GetNonceCalls gets all the calls that were made to GetNonce.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetNonceCalls())
func (mock *BlackfuryStateDBMock) GetNonceCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockGetNonce.RLock()
	calls = mock.calls.GetNonce
	mock.lockGetNonce.RUnlock()
	return calls
}

// GetOrNewStateObject calls GetOrNewStateObjectFunc.
func (mock *BlackfuryStateDBMock) GetOrNewStateObject(addr common.Address) *state.StateObject {
	if mock.GetOrNewStateObjectFunc == nil {
		panic("BlackfuryStateDBMock.GetOrNewStateObjectFunc: method is nil but BlackfuryStateDB.GetOrNewStateObject was just called")
	}
	callInfo := struct {
		Addr common.Address
	}{
		Addr: addr,
	}
	mock.lockGetOrNewStateObject.Lock()
	mock.calls.GetOrNewStateObject = append(mock.calls.GetOrNewStateObject, callInfo)
	mock.lockGetOrNewStateObject.Unlock()
	return mock.GetOrNewStateObjectFunc(addr)
}

// GetOrNewStateObjectCalls gets all the calls that were made to GetOrNewStateObject.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetOrNewStateObjectCalls())
func (mock *BlackfuryStateDBMock) GetOrNewStateObjectCalls() []struct {
	Addr common.Address
} {
	var calls []struct {
		Addr common.Address
	}
	mock.lockGetOrNewStateObject.RLock()
	calls = mock.calls.GetOrNewStateObject
	mock.lockGetOrNewStateObject.RUnlock()
	return calls
}

// GetProof calls GetProofFunc.
func (mock *BlackfuryStateDBMock) GetProof(addr common.Address) ([][]byte, error) {
	if mock.GetProofFunc == nil {
		panic("BlackfuryStateDBMock.GetProofFunc: method is nil but BlackfuryStateDB.GetProof was just called")
	}
	callInfo := struct {
		Addr common.Address
	}{
		Addr: addr,
	}
	mock.lockGetProof.Lock()
	mock.calls.GetProof = append(mock.calls.GetProof, callInfo)
	mock.lockGetProof.Unlock()
	return mock.GetProofFunc(addr)
}

// GetProofCalls gets all the calls that were made to GetProof.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetProofCalls())
func (mock *BlackfuryStateDBMock) GetProofCalls() []struct {
	Addr common.Address
} {
	var calls []struct {
		Addr common.Address
	}
	mock.lockGetProof.RLock()
	calls = mock.calls.GetProof
	mock.lockGetProof.RUnlock()
	return calls
}

// GetRefund calls GetRefundFunc.
func (mock *BlackfuryStateDBMock) GetRefund() uint64 {
	if mock.GetRefundFunc == nil {
		panic("BlackfuryStateDBMock.GetRefundFunc: method is nil but BlackfuryStateDB.GetRefund was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetRefund.Lock()
	mock.calls.GetRefund = append(mock.calls.GetRefund, callInfo)
	mock.lockGetRefund.Unlock()
	return mock.GetRefundFunc()
}

// GetRefundCalls gets all the calls that were made to GetRefund.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetRefundCalls())
func (mock *BlackfuryStateDBMock) GetRefundCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetRefund.RLock()
	calls = mock.calls.GetRefund
	mock.lockGetRefund.RUnlock()
	return calls
}

// GetState calls GetStateFunc.
func (mock *BlackfuryStateDBMock) GetState(address common.Address, hash common.Hash) common.Hash {
	if mock.GetStateFunc == nil {
		panic("BlackfuryStateDBMock.GetStateFunc: method is nil but BlackfuryStateDB.GetState was just called")
	}
	callInfo := struct {
		Address common.Address
		Hash    common.Hash
	}{
		Address: address,
		Hash:    hash,
	}
	mock.lockGetState.Lock()
	mock.calls.GetState = append(mock.calls.GetState, callInfo)
	mock.lockGetState.Unlock()
	return mock.GetStateFunc(address, hash)
}

// GetStateCalls gets all the calls that were made to GetState.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetStateCalls())
func (mock *BlackfuryStateDBMock) GetStateCalls() []struct {
	Address common.Address
	Hash    common.Hash
} {
	var calls []struct {
		Address common.Address
		Hash    common.Hash
	}
	mock.lockGetState.RLock()
	calls = mock.calls.GetState
	mock.lockGetState.RUnlock()
	return calls
}

// GetStorageProof calls GetStorageProofFunc.
func (mock *BlackfuryStateDBMock) GetStorageProof(a common.Address, key common.Hash) ([][]byte, error) {
	if mock.GetStorageProofFunc == nil {
		panic("BlackfuryStateDBMock.GetStorageProofFunc: method is nil but BlackfuryStateDB.GetStorageProof was just called")
	}
	callInfo := struct {
		A   common.Address
		Key common.Hash
	}{
		A:   a,
		Key: key,
	}
	mock.lockGetStorageProof.Lock()
	mock.calls.GetStorageProof = append(mock.calls.GetStorageProof, callInfo)
	mock.lockGetStorageProof.Unlock()
	return mock.GetStorageProofFunc(a, key)
}

// GetStorageProofCalls gets all the calls that were made to GetStorageProof.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetStorageProofCalls())
func (mock *BlackfuryStateDBMock) GetStorageProofCalls() []struct {
	A   common.Address
	Key common.Hash
} {
	var calls []struct {
		A   common.Address
		Key common.Hash
	}
	mock.lockGetStorageProof.RLock()
	calls = mock.calls.GetStorageProof
	mock.lockGetStorageProof.RUnlock()
	return calls
}

// GetTransientState calls GetTransientStateFunc.
func (mock *BlackfuryStateDBMock) GetTransientState(addr common.Address, key common.Hash) common.Hash {
	if mock.GetTransientStateFunc == nil {
		panic("BlackfuryStateDBMock.GetTransientStateFunc: method is nil but BlackfuryStateDB.GetTransientState was just called")
	}
	callInfo := struct {
		Addr common.Address
		Key  common.Hash
	}{
		Addr: addr,
		Key:  key,
	}
	mock.lockGetTransientState.Lock()
	mock.calls.GetTransientState = append(mock.calls.GetTransientState, callInfo)
	mock.lockGetTransientState.Unlock()
	return mock.GetTransientStateFunc(addr, key)
}

// GetTransientStateCalls gets all the calls that were made to GetTransientState.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.GetTransientStateCalls())
func (mock *BlackfuryStateDBMock) GetTransientStateCalls() []struct {
	Addr common.Address
	Key  common.Hash
} {
	var calls []struct {
		Addr common.Address
		Key  common.Hash
	}
	mock.lockGetTransientState.RLock()
	calls = mock.calls.GetTransientState
	mock.lockGetTransientState.RUnlock()
	return calls
}

// HasSuicided calls HasSuicidedFunc.
func (mock *BlackfuryStateDBMock) HasSuicided(address common.Address) bool {
	if mock.HasSuicidedFunc == nil {
		panic("BlackfuryStateDBMock.HasSuicidedFunc: method is nil but BlackfuryStateDB.HasSuicided was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockHasSuicided.Lock()
	mock.calls.HasSuicided = append(mock.calls.HasSuicided, callInfo)
	mock.lockHasSuicided.Unlock()
	return mock.HasSuicidedFunc(address)
}

// HasSuicidedCalls gets all the calls that were made to HasSuicided.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.HasSuicidedCalls())
func (mock *BlackfuryStateDBMock) HasSuicidedCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockHasSuicided.RLock()
	calls = mock.calls.HasSuicided
	mock.lockHasSuicided.RUnlock()
	return calls
}

// IntermediateRoot calls IntermediateRootFunc.
func (mock *BlackfuryStateDBMock) IntermediateRoot(deleteEmptyObjects bool) common.Hash {
	if mock.IntermediateRootFunc == nil {
		panic("BlackfuryStateDBMock.IntermediateRootFunc: method is nil but BlackfuryStateDB.IntermediateRoot was just called")
	}
	callInfo := struct {
		DeleteEmptyObjects bool
	}{
		DeleteEmptyObjects: deleteEmptyObjects,
	}
	mock.lockIntermediateRoot.Lock()
	mock.calls.IntermediateRoot = append(mock.calls.IntermediateRoot, callInfo)
	mock.lockIntermediateRoot.Unlock()
	return mock.IntermediateRootFunc(deleteEmptyObjects)
}

// IntermediateRootCalls gets all the calls that were made to IntermediateRoot.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.IntermediateRootCalls())
func (mock *BlackfuryStateDBMock) IntermediateRootCalls() []struct {
	DeleteEmptyObjects bool
} {
	var calls []struct {
		DeleteEmptyObjects bool
	}
	mock.lockIntermediateRoot.RLock()
	calls = mock.calls.IntermediateRoot
	mock.lockIntermediateRoot.RUnlock()
	return calls
}

// IteratorDump calls IteratorDumpFunc.
func (mock *BlackfuryStateDBMock) IteratorDump(opts *state.DumpConfig) state.IteratorDump {
	if mock.IteratorDumpFunc == nil {
		panic("BlackfuryStateDBMock.IteratorDumpFunc: method is nil but BlackfuryStateDB.IteratorDump was just called")
	}
	callInfo := struct {
		Opts *state.DumpConfig
	}{
		Opts: opts,
	}
	mock.lockIteratorDump.Lock()
	mock.calls.IteratorDump = append(mock.calls.IteratorDump, callInfo)
	mock.lockIteratorDump.Unlock()
	return mock.IteratorDumpFunc(opts)
}

// IteratorDumpCalls gets all the calls that were made to IteratorDump.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.IteratorDumpCalls())
func (mock *BlackfuryStateDBMock) IteratorDumpCalls() []struct {
	Opts *state.DumpConfig
} {
	var calls []struct {
		Opts *state.DumpConfig
	}
	mock.lockIteratorDump.RLock()
	calls = mock.calls.IteratorDump
	mock.lockIteratorDump.RUnlock()
	return calls
}

// Logs calls LogsFunc.
func (mock *BlackfuryStateDBMock) Logs() []*types.Log {
	if mock.LogsFunc == nil {
		panic("BlackfuryStateDBMock.LogsFunc: method is nil but BlackfuryStateDB.Logs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLogs.Lock()
	mock.calls.Logs = append(mock.calls.Logs, callInfo)
	mock.lockLogs.Unlock()
	return mock.LogsFunc()
}

// LogsCalls gets all the calls that were made to Logs.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.LogsCalls())
func (mock *BlackfuryStateDBMock) LogsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLogs.RLock()
	calls = mock.calls.Logs
	mock.lockLogs.RUnlock()
	return calls
}

// Preimages calls PreimagesFunc.
func (mock *BlackfuryStateDBMock) Preimages() map[common.Hash][]byte {
	if mock.PreimagesFunc == nil {
		panic("BlackfuryStateDBMock.PreimagesFunc: method is nil but BlackfuryStateDB.Preimages was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPreimages.Lock()
	mock.calls.Preimages = append(mock.calls.Preimages, callInfo)
	mock.lockPreimages.Unlock()
	return mock.PreimagesFunc()
}

// PreimagesCalls gets all the calls that were made to Preimages.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.PreimagesCalls())
func (mock *BlackfuryStateDBMock) PreimagesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPreimages.RLock()
	calls = mock.calls.Preimages
	mock.lockPreimages.RUnlock()
	return calls
}

// Prepare calls PrepareFunc.
func (mock *BlackfuryStateDBMock) Prepare(rules params.Rules, sender common.Address, coinbase common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList) {
	if mock.PrepareFunc == nil {
		panic("BlackfuryStateDBMock.PrepareFunc: method is nil but BlackfuryStateDB.Prepare was just called")
	}
	callInfo := struct {
		Rules       params.Rules
		Sender      common.Address
		Coinbase    common.Address
		Dest        *common.Address
		Precompiles []common.Address
		TxAccesses  types.AccessList
	}{
		Rules:       rules,
		Sender:      sender,
		Coinbase:    coinbase,
		Dest:        dest,
		Precompiles: precompiles,
		TxAccesses:  txAccesses,
	}
	mock.lockPrepare.Lock()
	mock.calls.Prepare = append(mock.calls.Prepare, callInfo)
	mock.lockPrepare.Unlock()
	mock.PrepareFunc(rules, sender, coinbase, dest, precompiles, txAccesses)
}

// PrepareCalls gets all the calls that were made to Prepare.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.PrepareCalls())
func (mock *BlackfuryStateDBMock) PrepareCalls() []struct {
	Rules       params.Rules
	Sender      common.Address
	Coinbase    common.Address
	Dest        *common.Address
	Precompiles []common.Address
	TxAccesses  types.AccessList
} {
	var calls []struct {
		Rules       params.Rules
		Sender      common.Address
		Coinbase    common.Address
		Dest        *common.Address
		Precompiles []common.Address
		TxAccesses  types.AccessList
	}
	mock.lockPrepare.RLock()
	calls = mock.calls.Prepare
	mock.lockPrepare.RUnlock()
	return calls
}

// RawDump calls RawDumpFunc.
func (mock *BlackfuryStateDBMock) RawDump(opts *state.DumpConfig) state.Dump {
	if mock.RawDumpFunc == nil {
		panic("BlackfuryStateDBMock.RawDumpFunc: method is nil but BlackfuryStateDB.RawDump was just called")
	}
	callInfo := struct {
		Opts *state.DumpConfig
	}{
		Opts: opts,
	}
	mock.lockRawDump.Lock()
	mock.calls.RawDump = append(mock.calls.RawDump, callInfo)
	mock.lockRawDump.Unlock()
	return mock.RawDumpFunc(opts)
}

// RawDumpCalls gets all the calls that were made to RawDump.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.RawDumpCalls())
func (mock *BlackfuryStateDBMock) RawDumpCalls() []struct {
	Opts *state.DumpConfig
} {
	var calls []struct {
		Opts *state.DumpConfig
	}
	mock.lockRawDump.RLock()
	calls = mock.calls.RawDump
	mock.lockRawDump.RUnlock()
	return calls
}

// RevertToSnapshot calls RevertToSnapshotFunc.
func (mock *BlackfuryStateDBMock) RevertToSnapshot(n int) {
	if mock.RevertToSnapshotFunc == nil {
		panic("BlackfuryStateDBMock.RevertToSnapshotFunc: method is nil but BlackfuryStateDB.RevertToSnapshot was just called")
	}
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockRevertToSnapshot.Lock()
	mock.calls.RevertToSnapshot = append(mock.calls.RevertToSnapshot, callInfo)
	mock.lockRevertToSnapshot.Unlock()
	mock.RevertToSnapshotFunc(n)
}

// RevertToSnapshotCalls gets all the calls that were made to RevertToSnapshot.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.RevertToSnapshotCalls())
func (mock *BlackfuryStateDBMock) RevertToSnapshotCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockRevertToSnapshot.RLock()
	calls = mock.calls.RevertToSnapshot
	mock.lockRevertToSnapshot.RUnlock()
	return calls
}

// SetBalance calls SetBalanceFunc.
func (mock *BlackfuryStateDBMock) SetBalance(addr common.Address, amount *big.Int) {
	if mock.SetBalanceFunc == nil {
		panic("BlackfuryStateDBMock.SetBalanceFunc: method is nil but BlackfuryStateDB.SetBalance was just called")
	}
	callInfo := struct {
		Addr   common.Address
		Amount *big.Int
	}{
		Addr:   addr,
		Amount: amount,
	}
	mock.lockSetBalance.Lock()
	mock.calls.SetBalance = append(mock.calls.SetBalance, callInfo)
	mock.lockSetBalance.Unlock()
	mock.SetBalanceFunc(addr, amount)
}

// SetBalanceCalls gets all the calls that were made to SetBalance.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetBalanceCalls())
func (mock *BlackfuryStateDBMock) SetBalanceCalls() []struct {
	Addr   common.Address
	Amount *big.Int
} {
	var calls []struct {
		Addr   common.Address
		Amount *big.Int
	}
	mock.lockSetBalance.RLock()
	calls = mock.calls.SetBalance
	mock.lockSetBalance.RUnlock()
	return calls
}

// SetCode calls SetCodeFunc.
func (mock *BlackfuryStateDBMock) SetCode(address common.Address, bytes []byte) {
	if mock.SetCodeFunc == nil {
		panic("BlackfuryStateDBMock.SetCodeFunc: method is nil but BlackfuryStateDB.SetCode was just called")
	}
	callInfo := struct {
		Address common.Address
		Bytes   []byte
	}{
		Address: address,
		Bytes:   bytes,
	}
	mock.lockSetCode.Lock()
	mock.calls.SetCode = append(mock.calls.SetCode, callInfo)
	mock.lockSetCode.Unlock()
	mock.SetCodeFunc(address, bytes)
}

// SetCodeCalls gets all the calls that were made to SetCode.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetCodeCalls())
func (mock *BlackfuryStateDBMock) SetCodeCalls() []struct {
	Address common.Address
	Bytes   []byte
} {
	var calls []struct {
		Address common.Address
		Bytes   []byte
	}
	mock.lockSetCode.RLock()
	calls = mock.calls.SetCode
	mock.lockSetCode.RUnlock()
	return calls
}

// SetNonce calls SetNonceFunc.
func (mock *BlackfuryStateDBMock) SetNonce(address common.Address, v uint64) {
	if mock.SetNonceFunc == nil {
		panic("BlackfuryStateDBMock.SetNonceFunc: method is nil but BlackfuryStateDB.SetNonce was just called")
	}
	callInfo := struct {
		Address common.Address
		V       uint64
	}{
		Address: address,
		V:       v,
	}
	mock.lockSetNonce.Lock()
	mock.calls.SetNonce = append(mock.calls.SetNonce, callInfo)
	mock.lockSetNonce.Unlock()
	mock.SetNonceFunc(address, v)
}

// SetNonceCalls gets all the calls that were made to SetNonce.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetNonceCalls())
func (mock *BlackfuryStateDBMock) SetNonceCalls() []struct {
	Address common.Address
	V       uint64
} {
	var calls []struct {
		Address common.Address
		V       uint64
	}
	mock.lockSetNonce.RLock()
	calls = mock.calls.SetNonce
	mock.lockSetNonce.RUnlock()
	return calls
}

// SetState calls SetStateFunc.
func (mock *BlackfuryStateDBMock) SetState(address common.Address, hash1 common.Hash, hash2 common.Hash) {
	if mock.SetStateFunc == nil {
		panic("BlackfuryStateDBMock.SetStateFunc: method is nil but BlackfuryStateDB.SetState was just called")
	}
	callInfo := struct {
		Address common.Address
		Hash1   common.Hash
		Hash2   common.Hash
	}{
		Address: address,
		Hash1:   hash1,
		Hash2:   hash2,
	}
	mock.lockSetState.Lock()
	mock.calls.SetState = append(mock.calls.SetState, callInfo)
	mock.lockSetState.Unlock()
	mock.SetStateFunc(address, hash1, hash2)
}

// SetStateCalls gets all the calls that were made to SetState.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetStateCalls())
func (mock *BlackfuryStateDBMock) SetStateCalls() []struct {
	Address common.Address
	Hash1   common.Hash
	Hash2   common.Hash
} {
	var calls []struct {
		Address common.Address
		Hash1   common.Hash
		Hash2   common.Hash
	}
	mock.lockSetState.RLock()
	calls = mock.calls.SetState
	mock.lockSetState.RUnlock()
	return calls
}

// SetStorage calls SetStorageFunc.
func (mock *BlackfuryStateDBMock) SetStorage(addr common.Address, storage map[common.Hash]common.Hash) {
	if mock.SetStorageFunc == nil {
		panic("BlackfuryStateDBMock.SetStorageFunc: method is nil but BlackfuryStateDB.SetStorage was just called")
	}
	callInfo := struct {
		Addr    common.Address
		Storage map[common.Hash]common.Hash
	}{
		Addr:    addr,
		Storage: storage,
	}
	mock.lockSetStorage.Lock()
	mock.calls.SetStorage = append(mock.calls.SetStorage, callInfo)
	mock.lockSetStorage.Unlock()
	mock.SetStorageFunc(addr, storage)
}

// SetStorageCalls gets all the calls that were made to SetStorage.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetStorageCalls())
func (mock *BlackfuryStateDBMock) SetStorageCalls() []struct {
	Addr    common.Address
	Storage map[common.Hash]common.Hash
} {
	var calls []struct {
		Addr    common.Address
		Storage map[common.Hash]common.Hash
	}
	mock.lockSetStorage.RLock()
	calls = mock.calls.SetStorage
	mock.lockSetStorage.RUnlock()
	return calls
}

// SetTransientState calls SetTransientStateFunc.
func (mock *BlackfuryStateDBMock) SetTransientState(addr common.Address, key common.Hash, value common.Hash) {
	if mock.SetTransientStateFunc == nil {
		panic("BlackfuryStateDBMock.SetTransientStateFunc: method is nil but BlackfuryStateDB.SetTransientState was just called")
	}
	callInfo := struct {
		Addr  common.Address
		Key   common.Hash
		Value common.Hash
	}{
		Addr:  addr,
		Key:   key,
		Value: value,
	}
	mock.lockSetTransientState.Lock()
	mock.calls.SetTransientState = append(mock.calls.SetTransientState, callInfo)
	mock.lockSetTransientState.Unlock()
	mock.SetTransientStateFunc(addr, key, value)
}

// SetTransientStateCalls gets all the calls that were made to SetTransientState.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetTransientStateCalls())
func (mock *BlackfuryStateDBMock) SetTransientStateCalls() []struct {
	Addr  common.Address
	Key   common.Hash
	Value common.Hash
} {
	var calls []struct {
		Addr  common.Address
		Key   common.Hash
		Value common.Hash
	}
	mock.lockSetTransientState.RLock()
	calls = mock.calls.SetTransientState
	mock.lockSetTransientState.RUnlock()
	return calls
}

// SetTxContext calls SetTxContextFunc.
func (mock *BlackfuryStateDBMock) SetTxContext(thash common.Hash, ti int) {
	if mock.SetTxContextFunc == nil {
		panic("BlackfuryStateDBMock.SetTxContextFunc: method is nil but BlackfuryStateDB.SetTxContext was just called")
	}
	callInfo := struct {
		Thash common.Hash
		Ti    int
	}{
		Thash: thash,
		Ti:    ti,
	}
	mock.lockSetTxContext.Lock()
	mock.calls.SetTxContext = append(mock.calls.SetTxContext, callInfo)
	mock.lockSetTxContext.Unlock()
	mock.SetTxContextFunc(thash, ti)
}

// SetTxContextCalls gets all the calls that were made to SetTxContext.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SetTxContextCalls())
func (mock *BlackfuryStateDBMock) SetTxContextCalls() []struct {
	Thash common.Hash
	Ti    int
} {
	var calls []struct {
		Thash common.Hash
		Ti    int
	}
	mock.lockSetTxContext.RLock()
	calls = mock.calls.SetTxContext
	mock.lockSetTxContext.RUnlock()
	return calls
}

// SlotInAccessList calls SlotInAccessListFunc.
func (mock *BlackfuryStateDBMock) SlotInAccessList(addr common.Address, slot common.Hash) (bool, bool) {
	if mock.SlotInAccessListFunc == nil {
		panic("BlackfuryStateDBMock.SlotInAccessListFunc: method is nil but BlackfuryStateDB.SlotInAccessList was just called")
	}
	callInfo := struct {
		Addr common.Address
		Slot common.Hash
	}{
		Addr: addr,
		Slot: slot,
	}
	mock.lockSlotInAccessList.Lock()
	mock.calls.SlotInAccessList = append(mock.calls.SlotInAccessList, callInfo)
	mock.lockSlotInAccessList.Unlock()
	return mock.SlotInAccessListFunc(addr, slot)
}

// SlotInAccessListCalls gets all the calls that were made to SlotInAccessList.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SlotInAccessListCalls())
func (mock *BlackfuryStateDBMock) SlotInAccessListCalls() []struct {
	Addr common.Address
	Slot common.Hash
} {
	var calls []struct {
		Addr common.Address
		Slot common.Hash
	}
	mock.lockSlotInAccessList.RLock()
	calls = mock.calls.SlotInAccessList
	mock.lockSlotInAccessList.RUnlock()
	return calls
}

// Snapshot calls SnapshotFunc.
func (mock *BlackfuryStateDBMock) Snapshot() int {
	if mock.SnapshotFunc == nil {
		panic("BlackfuryStateDBMock.SnapshotFunc: method is nil but BlackfuryStateDB.Snapshot was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSnapshot.Lock()
	mock.calls.Snapshot = append(mock.calls.Snapshot, callInfo)
	mock.lockSnapshot.Unlock()
	return mock.SnapshotFunc()
}

// SnapshotCalls gets all the calls that were made to Snapshot.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SnapshotCalls())
func (mock *BlackfuryStateDBMock) SnapshotCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSnapshot.RLock()
	calls = mock.calls.Snapshot
	mock.lockSnapshot.RUnlock()
	return calls
}

// StartPrefetcher calls StartPrefetcherFunc.
func (mock *BlackfuryStateDBMock) StartPrefetcher(namespace string) {
	if mock.StartPrefetcherFunc == nil {
		panic("BlackfuryStateDBMock.StartPrefetcherFunc: method is nil but BlackfuryStateDB.StartPrefetcher was just called")
	}
	callInfo := struct {
		Namespace string
	}{
		Namespace: namespace,
	}
	mock.lockStartPrefetcher.Lock()
	mock.calls.StartPrefetcher = append(mock.calls.StartPrefetcher, callInfo)
	mock.lockStartPrefetcher.Unlock()
	mock.StartPrefetcherFunc(namespace)
}

// StartPrefetcherCalls gets all the calls that were made to StartPrefetcher.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.StartPrefetcherCalls())
func (mock *BlackfuryStateDBMock) StartPrefetcherCalls() []struct {
	Namespace string
} {
	var calls []struct {
		Namespace string
	}
	mock.lockStartPrefetcher.RLock()
	calls = mock.calls.StartPrefetcher
	mock.lockStartPrefetcher.RUnlock()
	return calls
}

// StopPrefetcher calls StopPrefetcherFunc.
func (mock *BlackfuryStateDBMock) StopPrefetcher() {
	if mock.StopPrefetcherFunc == nil {
		panic("BlackfuryStateDBMock.StopPrefetcherFunc: method is nil but BlackfuryStateDB.StopPrefetcher was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStopPrefetcher.Lock()
	mock.calls.StopPrefetcher = append(mock.calls.StopPrefetcher, callInfo)
	mock.lockStopPrefetcher.Unlock()
	mock.StopPrefetcherFunc()
}

// StopPrefetcherCalls gets all the calls that were made to StopPrefetcher.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.StopPrefetcherCalls())
func (mock *BlackfuryStateDBMock) StopPrefetcherCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStopPrefetcher.RLock()
	calls = mock.calls.StopPrefetcher
	mock.lockStopPrefetcher.RUnlock()
	return calls
}

// StorageTrie calls StorageTrieFunc.
func (mock *BlackfuryStateDBMock) StorageTrie(addr common.Address) (state.Trie, error) {
	if mock.StorageTrieFunc == nil {
		panic("BlackfuryStateDBMock.StorageTrieFunc: method is nil but BlackfuryStateDB.StorageTrie was just called")
	}
	callInfo := struct {
		Addr common.Address
	}{
		Addr: addr,
	}
	mock.lockStorageTrie.Lock()
	mock.calls.StorageTrie = append(mock.calls.StorageTrie, callInfo)
	mock.lockStorageTrie.Unlock()
	return mock.StorageTrieFunc(addr)
}

// StorageTrieCalls gets all the calls that were made to StorageTrie.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.StorageTrieCalls())
func (mock *BlackfuryStateDBMock) StorageTrieCalls() []struct {
	Addr common.Address
} {
	var calls []struct {
		Addr common.Address
	}
	mock.lockStorageTrie.RLock()
	calls = mock.calls.StorageTrie
	mock.lockStorageTrie.RUnlock()
	return calls
}

// SubBalance calls SubBalanceFunc.
func (mock *BlackfuryStateDBMock) SubBalance(address common.Address, intMoqParam *big.Int) {
	if mock.SubBalanceFunc == nil {
		panic("BlackfuryStateDBMock.SubBalanceFunc: method is nil but BlackfuryStateDB.SubBalance was just called")
	}
	callInfo := struct {
		Address     common.Address
		IntMoqParam *big.Int
	}{
		Address:     address,
		IntMoqParam: intMoqParam,
	}
	mock.lockSubBalance.Lock()
	mock.calls.SubBalance = append(mock.calls.SubBalance, callInfo)
	mock.lockSubBalance.Unlock()
	mock.SubBalanceFunc(address, intMoqParam)
}

// SubBalanceCalls gets all the calls that were made to SubBalance.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SubBalanceCalls())
func (mock *BlackfuryStateDBMock) SubBalanceCalls() []struct {
	Address     common.Address
	IntMoqParam *big.Int
} {
	var calls []struct {
		Address     common.Address
		IntMoqParam *big.Int
	}
	mock.lockSubBalance.RLock()
	calls = mock.calls.SubBalance
	mock.lockSubBalance.RUnlock()
	return calls
}

// SubRefund calls SubRefundFunc.
func (mock *BlackfuryStateDBMock) SubRefund(v uint64) {
	if mock.SubRefundFunc == nil {
		panic("BlackfuryStateDBMock.SubRefundFunc: method is nil but BlackfuryStateDB.SubRefund was just called")
	}
	callInfo := struct {
		V uint64
	}{
		V: v,
	}
	mock.lockSubRefund.Lock()
	mock.calls.SubRefund = append(mock.calls.SubRefund, callInfo)
	mock.lockSubRefund.Unlock()
	mock.SubRefundFunc(v)
}

// SubRefundCalls gets all the calls that were made to SubRefund.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SubRefundCalls())
func (mock *BlackfuryStateDBMock) SubRefundCalls() []struct {
	V uint64
} {
	var calls []struct {
		V uint64
	}
	mock.lockSubRefund.RLock()
	calls = mock.calls.SubRefund
	mock.lockSubRefund.RUnlock()
	return calls
}

// Suicide calls SuicideFunc.
func (mock *BlackfuryStateDBMock) Suicide(address common.Address) bool {
	if mock.SuicideFunc == nil {
		panic("BlackfuryStateDBMock.SuicideFunc: method is nil but BlackfuryStateDB.Suicide was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockSuicide.Lock()
	mock.calls.Suicide = append(mock.calls.Suicide, callInfo)
	mock.lockSuicide.Unlock()
	return mock.SuicideFunc(address)
}

// SuicideCalls gets all the calls that were made to Suicide.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.SuicideCalls())
func (mock *BlackfuryStateDBMock) SuicideCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockSuicide.RLock()
	calls = mock.calls.Suicide
	mock.lockSuicide.RUnlock()
	return calls
}

// TxIndex calls TxIndexFunc.
func (mock *BlackfuryStateDBMock) TxIndex() int {
	if mock.TxIndexFunc == nil {
		panic("BlackfuryStateDBMock.TxIndexFunc: method is nil but BlackfuryStateDB.TxIndex was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTxIndex.Lock()
	mock.calls.TxIndex = append(mock.calls.TxIndex, callInfo)
	mock.lockTxIndex.Unlock()
	return mock.TxIndexFunc()
}

// TxIndexCalls gets all the calls that were made to TxIndex.
// Check the length with:
//
//	len(mockedBlackfuryStateDB.TxIndexCalls())
func (mock *BlackfuryStateDBMock) TxIndexCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTxIndex.RLock()
	calls = mock.calls.TxIndex
	mock.lockTxIndex.RUnlock()
	return calls
}
